Index: src/Str.php
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+><?php\n\ndeclare(strict_types=1);\n\nnamespace Nip\\Utility;\n\nuse Exception;\nuse Nip\\Collections\\Collection;\nuse voku\\helper\\ASCII;\n\n/**\n * Class Str\n * @package Nip\\Utility\n */\nclass Str\n{\n    /**\n     * The cache of snake-cased words.\n     *\n     * @var array\n     */\n    protected static $snakeCache = [];\n\n    /**\n     * The cache of camel-cased words.\n     *\n     * @var array\n     */\n    protected static $camelCache = [];\n\n    /**\n     * The cache of studly-cased words.\n     *\n     * @var array\n     */\n    protected static $studlyCache = [];\n\n    /**\n     * Return the remainder of a string after the first occurrence of a given value.\n     *\n     * @param   string  $subject\n     * @param   string  $search\n     *\n     * @return string\n     */\n    public static function after(string $subject, string $search): string\n    {\n        return $search === '' ? $subject : array_reverse(explode($search, $subject, 2))[0];\n    }\n\n    /**\n     * Return the remainder of a string after the last occurrence of a given value.\n     *\n     * @param   string  $subject\n     * @param   string  $search\n     *\n     * @return string\n     */\n    public static function afterLast($subject, $search)\n    {\n        if ($search === '') {\n            return $subject;\n        }\n\n        $position = strrpos($subject, (string)$search);\n\n        if ($position === false) {\n            return $subject;\n        }\n\n        return substr($subject, $position + strlen($search));\n    }\n\n\n    /**\n     * Get the portion of a string before the first occurrence of a given value.\n     *\n     * @param   string  $subject\n     * @param   string  $search\n     *\n     * @return string\n     */\n    public static function before($subject, $search)\n    {\n        return $search === '' ? $subject : explode($search, $subject)[0];\n    }\n\n    /**\n     * Get the portion of a string before the last occurrence of a given value.\n     *\n     * @param   string  $subject\n     * @param   string  $search\n     *\n     * @return string\n     */\n    public static function beforeLast($subject, $search)\n    {\n        if ($search === '') {\n            return $subject;\n        }\n\n        $pos = mb_strrpos($subject, $search);\n\n        if ($pos === false) {\n            return $subject;\n        }\n\n        return static::substr($subject, 0, $pos);\n    }\n\n    /**\n     * Convert a value to camel case.\n     *\n     * @param   string  $value\n     *\n     * @return string\n     */\n    public static function camel($value)\n    {\n        if (isset(static::$camelCache[$value])) {\n            return static::$camelCache[$value];\n        }\n\n        return static::$camelCache[$value] = lcfirst(static::studly($value));\n    }\n\n    /**\n     * Convert a value to studly caps case.\n     *\n     * @param   string  $value\n     *\n     * @return string\n     */\n    public static function studly($value)\n    {\n        $key = $value;\n        if (isset(static::$studlyCache[$key])) {\n            return static::$studlyCache[$key];\n        }\n        $value = ucwords(str_replace(['-', '_'], ' ', $value));\n\n        return static::$studlyCache[$key] = str_replace(' ', '', $value);\n    }\n\n    /**\n     * Determine if a given string ends with a given substring.\n     *\n     * @param   string        $haystack\n     * @param   string|array  $needles\n     *\n     * @return bool\n     */\n    public static function endsWith($haystack, $needles)\n    {\n        foreach ((array)$needles as $needle) {\n            if (substr($haystack, -strlen($needle)) === (string)$needle) {\n                return true;\n            }\n        }\n\n        return false;\n    }\n\n    /**\n     * Cap a string with a single instance of a given value.\n     *\n     * @param   string  $value\n     * @param   string  $cap\n     *\n     * @return string\n     */\n    public static function finish($value, $cap)\n    {\n        $quoted = preg_quote($cap, '/');\n\n        return preg_replace('/(?:' . $quoted . ')+$/u', '', $value) . $cap;\n    }\n\n\n    /**\n     * Determine if a given string matches a given pattern.\n     *\n     * @param   string|array  $pattern\n     * @param   string        $value\n     *\n     * @return bool\n     */\n    public static function is($pattern, $value)\n    {\n        $patterns = Arr::wrap($pattern);\n\n        $value = (string)$value;\n\n        if (empty($patterns)) {\n            return false;\n        }\n\n        foreach ($patterns as $pattern) {\n            $pattern = (string)$pattern;\n\n            // If the given value is an exact match we can of course return true right\n            // from the beginning. Otherwise, we will translate asterisks and do an\n            // actual pattern match against the two strings to see if they match.\n            if ($pattern == $value) {\n                return true;\n            }\n\n            $pattern = preg_quote($pattern, '#');\n\n            // Asterisks are translated into zero-or-more regular expression wildcards\n            // to make it convenient to check if the strings starts with the given\n            // pattern such as \"library/*\", making any string check convenient.\n            $pattern = str_replace('\\*', '.*', $pattern);\n\n            if (preg_match('#^' . $pattern . '\\z#u', $value) === 1) {\n                return true;\n            }\n        }\n\n        return false;\n    }\n\n    /**\n     * Determine if a given string is 7 bit ASCII.\n     *\n     * @param   string  $value\n     *\n     * @return bool\n     */\n    public static function isAscii($value): bool\n    {\n        return ASCII::is_ascii((string)$value);\n    }\n\n    /**\n     * Determine if a given string is a valid UUID.\n     *\n     * @param   string  $value\n     *\n     * @return bool\n     */\n    public static function isUuid($value): bool\n    {\n        if (!is_string($value)) {\n            return false;\n        }\n\n        return preg_match('/^[\\da-f]{8}-[\\da-f]{4}-[\\da-f]{4}-[\\da-f]{4}-[\\da-f]{12}$/iD', $value) > 0;\n    }\n\n    /**\n     * Convert a string to kebab case.\n     *\n     * @param   string  $value\n     *\n     * @return string\n     */\n    public static function kebab($value)\n    {\n        return static::snake($value, '-');\n    }\n\n    /**\n     * Convert a string to snake case.\n     *\n     * @param   string  $value\n     * @param   string  $delimiter\n     *\n     * @return string\n     */\n    public static function snake($value, $delimiter = '_')\n    {\n        $key = $value;\n        if (isset(static::$snakeCache[$key][$delimiter])) {\n            return static::$snakeCache[$key][$delimiter];\n        }\n        if (!ctype_lower($value)) {\n            $value = preg_replace('/\\s+/u', '', $value);\n            $value = static::lower(preg_replace('/(.)(?=[A-Z])/u', '$1' . $delimiter, $value));\n        }\n\n        return static::$snakeCache[$key][$delimiter] = $value;\n    }\n\n    /**\n     * Convert the given string to lower-case.\n     *\n     * @param   string  $value\n     *\n     * @return string\n     */\n    public static function lower($value)\n    {\n        return mb_strtolower($value, 'UTF-8');\n    }\n\n    /**\n     * Limit the number of characters in a string.\n     *\n     * @param   string  $value\n     * @param   int     $limit\n     * @param   string  $end\n     *\n     * @return string\n     */\n    public static function limit($value, $limit = 100, $end = '...')\n    {\n        if (mb_strwidth($value, 'UTF-8') <= $limit) {\n            return $value;\n        }\n\n        /** @noinspection PhpComposerExtensionStubsInspection */\n        return rtrim(mb_strimwidth($value, 0, $limit, '', 'UTF-8')) . $end;\n    }\n\n    /**\n     * Limit the number of words in a string.\n     *\n     * @param   string  $value\n     * @param   int     $words\n     * @param   string  $end\n     *\n     * @return string\n     */\n    public static function words($value, $words = 100, $end = '...')\n    {\n        preg_match('/^\\s*+(?:\\S++\\s*+){1,' . $words . '}/u', $value, $matches);\n        if (!isset($matches[0]) || static::length($value) === static::length($matches[0])) {\n            return $value;\n        }\n\n        return rtrim($matches[0]) . $end;\n    }\n\n    /**\n     * Return the length of the given string.\n     *\n     * @param   string  $value\n     *\n     * @return int\n     */\n    public static function length($value)\n    {\n        return mb_strlen($value);\n    }\n\n    /**\n     * Parse a Class(at)method style callback into class and method.\n     *\n     * @param   string       $callback\n     * @param   string|null  $default\n     *\n     * @return array\n     */\n    public static function parseCallback($callback, $default = null)\n    {\n        return static::contains($callback, '@') ? explode('@', $callback, 2) : [$callback, $default];\n    }\n\n    /**\n     * Determine if a given string contains a given substring.\n     *\n     * @param   string        $haystack\n     * @param   string|array  $needles\n     *\n     * @return bool\n     */\n    public static function contains($haystack, $needles)\n    {\n        foreach ((array)$needles as $needle) {\n            if ($needle != '' && mb_strpos($haystack, $needle) !== false) {\n                return true;\n            }\n        }\n\n        return false;\n    }\n\n    /**\n     * Determine if a given string contains all array values.\n     *\n     * @param   string    $haystack\n     * @param   string[]  $needles\n     *\n     * @return bool\n     */\n    public static function containsAll($haystack, array $needles)\n    {\n        foreach ($needles as $needle) {\n            if (!static::contains($haystack, $needle)) {\n                return false;\n            }\n        }\n\n        return true;\n    }\n\n    /**\n     * Get the plural form of an English word.\n     *\n     * @param   string  $value\n     * @param   int     $count\n     *\n     * @return string\n     * @throws Exception\n     */\n    public static function plural(string $value, $count = 2): string\n    {\n        if (function_exists('inflector')) {\n            return inflector()->pluralize($value);\n        }\n        throw new Exception(\"Plural fuction needs bytic/inflector\");\n    }\n\n    /**\n     * Pluralize the last word of an English, studly caps case string.\n     *\n     * @param   string  $value\n     * @param   int     $count\n     *\n     * @return string\n     */\n    public static function pluralStudly($value, $count = 2)\n    {\n        $parts = preg_split('/(.)(?=[A-Z])/u', $value, -1, PREG_SPLIT_DELIM_CAPTURE);\n\n        $lastWord = array_pop($parts);\n\n        return implode('', $parts) . self::plural($lastWord, $count);\n    }\n\n    /**\n     * Generate a more truly \"random\" alpha-numeric string.\n     *\n     * @param   int  $length\n     *\n     * @return string\n     * @throws Exception\n     */\n    public static function random($length = 16): string\n    {\n        $string = '';\n        while (($len = strlen($string)) < $length) {\n            $size   = $length - $len;\n            $bytes  = random_bytes($size);\n            $string .= substr(str_replace(['/', '+', '='], '', base64_encode($bytes)), 0, $size);\n        }\n\n        return $string;\n    }\n\n    /**\n     * Repeat the given string.\n     *\n     * @param   string  $string\n     * @param   int     $times\n     *\n     * @return string\n     */\n    public static function repeat(string $string, int $times)\n    {\n        return str_repeat($string, $times);\n    }\n\n    /**\n     * Replace a given value in the string sequentially with an array.\n     *\n     * @param   string  $search\n     * @param   array   $replace\n     * @param   string  $subject\n     *\n     * @return string\n     */\n    public static function replaceArray($search, array $replace, $subject)\n    {\n        foreach ($replace as $value) {\n            $subject = static::replaceFirst($search, $value, $subject);\n        }\n\n        return $subject;\n    }\n\n    /**\n     * Replace the given value in the given string.\n     *\n     * @param   string|string[]  $search\n     * @param   string|string[]  $replace\n     * @param   string|string[]  $subject\n     *\n     * @return string\n     */\n    public static function replace($search, $replace, $subject)\n    {\n        return str_replace($search, $replace, $subject);\n    }\n\n    /**\n     * Replace the first occurrence of a given value in the string.\n     *\n     * @param   string  $search\n     * @param   string  $replace\n     * @param   string  $subject\n     *\n     * @return string\n     */\n    public static function replaceFirst($search, $replace, $subject)\n    {\n        $position = strpos($subject, $search);\n        if ($position !== false) {\n            return substr_replace($subject, $replace, $position, strlen($search));\n        }\n\n        return $subject;\n    }\n\n    /**\n     * Replace the last occurrence of a given value in the string.\n     *\n     * @param   string  $search\n     * @param   string  $replace\n     * @param   string  $subject\n     *\n     * @return string\n     */\n    public static function replaceLast($search, $replace, $subject)\n    {\n        $position = strrpos($subject, $search);\n        if ($position !== false) {\n            return substr_replace($subject, $replace, $position, strlen($search));\n        }\n\n        return $subject;\n    }\n\n    /**\n     * Remove any occurrence of the given string in the subject.\n     *\n     * @param   string|array<string>  $search\n     * @param   string                $subject\n     * @param   bool                  $caseSensitive\n     *\n     * @return string\n     */\n    public static function remove($search, $subject, $caseSensitive = true)\n    {\n        $subject = $caseSensitive\n            ? str_replace($search, '', $subject)\n            : str_ireplace($search, '', $subject);\n\n        return $subject;\n    }\n\n    /**\n     * Convert the given string to title case.\n     *\n     * @param   string  $value\n     *\n     * @return string\n     */\n    public static function title($value)\n    {\n        return mb_convert_case($value, MB_CASE_TITLE, 'UTF-8');\n    }\n\n    /**\n     * Convert the given string to title case for each word.\n     *\n     * @param   string  $value\n     *\n     * @return string\n     */\n    public static function headline($value)\n    {\n        $parts = explode('_', static::replace(' ', '_', $value));\n\n        if (count($parts) > 1) {\n            $parts = array_map([static::class, 'title'], $parts);\n        }\n\n        $studly = static::studly(implode($parts));\n\n        $words = preg_split('/(?=[A-Z])/', $studly, -1, PREG_SPLIT_NO_EMPTY);\n\n        return implode(' ', $words);\n    }\n\n    /**\n     * Get the singular form of an English word.\n     *\n     * @param   string  $value\n     *\n     * @return string\n     */\n    public static function singular($value)\n    {\n        return Pluralizer::singular($value);\n    }\n\n    /**\n     * Generate a URL friendly \"slug\" from a given string.\n     *\n     * @param   string  $title\n     * @param   string  $separator\n     *\n     * @return string\n     */\n    public static function slug($title, $separator = '-')\n    {\n        $title = static::ascii($title);\n        // Convert all dashes/underscores into separator\n        $flip  = $separator == '-' ? '_' : '-';\n        $title = preg_replace('![' . preg_quote($flip) . ']+!u', $separator, $title);\n        // Remove all characters that are not the separator, letters, numbers, or whitespace.\n        $title = preg_replace('![^' . preg_quote($separator) . '\\pL\\pN\\s]+!u', '', mb_strtolower($title));\n        // Replace all separator characters and whitespace by a single separator\n        $title = preg_replace('![' . preg_quote($separator) . '\\s]+!u', $separator, $title);\n\n        return trim($title, $separator);\n    }\n\n    /**\n     * Transliterate a UTF-8 value to ASCII.\n     *\n     * @param   string  $value\n     * @param   string  $language\n     *\n     * @return string\n     */\n    public static function ascii($value, $language = 'en')\n    {\n        return ASCII::to_ascii((string)$value, $language);\n    }\n\n    /**\n     * Returns the replacements for the ascii method.\n     *\n     * Note: Adapted from Stringy\\Stringy.\n     *\n     * @see https://github.com/danielstjules/Stringy/blob/2.3.1/LICENSE.txt\n     *\n     * @return array\n     */\n    protected static function charsArray()\n    {\n        static $charsArray;\n        if (isset($charsArray)) {\n            return $charsArray;\n        }\n\n        return $charsArray = require dirname(__DIR__) . '/data/charsArray.php';\n    }\n\n    /**\n     * Determine if a given string starts with a given substring.\n     *\n     * @param   string        $haystack\n     * @param   string|array  $needles\n     *\n     * @return bool\n     */\n    public static function startsWith($haystack, $needles)\n    {\n        foreach ((array)$needles as $needle) {\n            if ($needle != '' && substr($haystack, 0, strlen($needle)) === (string)$needle) {\n                return true;\n            }\n        }\n\n        return false;\n    }\n\n    /**\n     * Make a string's first character uppercase.\n     *\n     * @param   string  $string\n     *\n     * @return string\n     */\n    public static function ucfirst($string)\n    {\n        return static::upper(static::substr($string, 0, 1)) . static::substr($string, 1);\n    }\n\n    /**\n     * Get the number of words a string contains.\n     *\n     * @param   string  $string\n     *\n     * @return int\n     */\n    public static function wordCount($string)\n    {\n        return str_word_count($string);\n    }\n\n    /**\n     * Convert the given string to upper-case.\n     *\n     * @param   string  $value\n     *\n     * @return string\n     */\n    public static function upper($value)\n    {\n        return mb_strtoupper($value, 'UTF-8');\n    }\n\n    /**\n     * Returns the portion of string specified by the start and length parameters.\n     *\n     * @param   string    $string\n     * @param   int       $start\n     * @param   int|null  $length\n     *\n     * @return string\n     */\n    public static function substr($string, $start, $length = null)\n    {\n        return mb_substr($string, $start, $length, 'UTF-8');\n    }\n\n    /**\n     * Returns the number of substring occurrences.\n     *\n     * @param   string    $haystack\n     * @param   string    $needle\n     * @param   int       $offset\n     * @param   int|null  $length\n     *\n     * @return int\n     */\n    public static function substrCount($haystack, $needle, $offset = 0, $length = null)\n    {\n        if (!is_null($length)) {\n            return substr_count($haystack, $needle, $offset, $length);\n        } else {\n            return substr_count($haystack, $needle, $offset);\n        }\n    }\n\n    /**\n     * @param         $data\n     * @param   bool  $strict\n     *\n     * @return bool\n     */\n    public static function isSerialized($data, $strict = true)\n    {\n        // if it isn't a string, it isn't serialized.\n        if (!is_string($data)) {\n            return false;\n        }\n        $data = trim($data);\n        if ('N;' == $data) {\n            return true;\n        }\n        if (strlen($data) < 4) {\n            return false;\n        }\n        if (':' !== $data[1]) {\n            return false;\n        }\n        if ($strict) {\n            $lastc = substr($data, -1);\n            if (';' !== $lastc && '}' !== $lastc) {\n                return false;\n            }\n        } else {\n            $semicolon = strpos($data, ';');\n            $brace     = strpos($data, '}');\n            // Either ; or } must exist.\n            if (false === $semicolon && false === $brace) {\n                return false;\n            }\n            // But neither must be in the first X characters.\n            if (false !== $semicolon && $semicolon < 3) {\n                return false;\n            }\n            if (false !== $brace && $brace < 4) {\n                return false;\n            }\n        }\n        $token = $data[0];\n        switch ($token) {\n            case 's':\n                if ($strict) {\n                    if ('\"' !== substr($data, -2, 1)) {\n                        return false;\n                    }\n                } elseif (false === strpos($data, '\"')) {\n                    return false;\n                }\n            // or else fall through\n            // no break\n            case 'a':\n            case 'O':\n                return (bool)preg_match(\"/^{$token}:[0-9]+:/s\", $data);\n            case 'b':\n            case 'i':\n            case 'd':\n                $end = $strict ? '$' : '';\n\n                return (bool)preg_match(\"/^{$token}:[0-9.E-]+;$end/\", $data);\n        }\n\n        return false;\n    }\n\n    /**\n     * @param $str\n     * @param $first\n     * @param $last\n     *\n     * @return string\n     */\n    public static function mask($str, $first = 0, $last = 0)\n    {\n        $len    = strlen($str);\n        $toShow = $first + $last;\n\n        return substr($str, 0, $len <= $toShow ? 0 : $first)\n            . str_repeat(\"*\", $len - ($len <= $toShow ? 0 : $toShow))\n            . substr($str, $len - $last, $len <= $toShow ? 0 : $last);\n    }\n\n    /**\n     * Get the string matching the given pattern.\n     *\n     * @param   string  $pattern\n     * @param   string  $subject\n     *\n     * @return string\n     */\n    public static function match($pattern, $subject)\n    {\n        preg_match($pattern, $subject, $matches);\n\n        if (!$matches) {\n            return '';\n        }\n\n        return $matches[1] ?? $matches[0];\n    }\n\n    /**\n     * Get the string matching the given pattern.\n     *\n     * @param   string  $pattern\n     * @param   string  $subject\n     *\n     * @return Collection\n     */\n    public static function matchAll($pattern, $subject)\n    {\n        preg_match_all($pattern, $subject, $matches);\n\n        if (empty($matches[0])) {\n            return collect();\n        }\n\n        return collect($matches[1] ?? $matches[0]);\n    }\n\n    /**\n     * Pad both sides of a string with another.\n     *\n     * @param   string  $value\n     * @param   int     $length\n     * @param   string  $pad\n     *\n     * @return string\n     */\n    public static function padBoth($value, $length, $pad = ' ')\n    {\n        return str_pad($value, $length, $pad, STR_PAD_BOTH);\n    }\n\n    /**\n     * Pad the left side of a string with another.\n     *\n     * @param   string  $value\n     * @param   int     $length\n     * @param   string  $pad\n     *\n     * @return string\n     */\n    public static function padLeft($value, $length, $pad = ' ')\n    {\n        return str_pad($value, $length, $pad, STR_PAD_LEFT);\n    }\n\n    /**\n     * Pad the right side of a string with another.\n     *\n     * @param   string  $value\n     * @param   int     $length\n     * @param   string  $pad\n     *\n     * @return string\n     */\n    public static function padRight($value, $length, $pad = ' ')\n    {\n        return str_pad($value, $length, $pad, STR_PAD_RIGHT);\n    }\n\n    /**\n     * @param           $name\n     * @param   string  $separator\n     *\n     * @return string\n     */\n    public static function initials($name, $separator = '.')\n    {\n        $name     = str_replace(['-', '_'], ' ', $name);\n        $split    = explode(\" \", $name);\n        $split    = array_filter($split, function ($part) {\n            return !empty($part);\n        });\n        $initials = [];\n        foreach ($split as $part) {\n            $initials[] = ucfirst($part[0]);\n        }\n\n        return implode($separator, $initials) . $separator;\n    }\n\n    /**\n     * @param   string  $string\n     * @param   bool    $return\n     * @param   array   $params\n     *\n     * @return bool|mixed\n     */\n    public static function isJson(string $string, $return = false, ...$params)\n    {\n        $data = json_decode($string, ...$params);\n        if (json_last_error() !== JSON_ERROR_NONE) {\n            return false;\n        }\n\n        return $return ? $data : true;\n    }\n\n    /**\n     * Determine if the given value is a standard date format.\n     *\n     * @param   string  $value\n     *\n     * @return bool\n     */\n    public static function isStandardDateFormat($value)\n    {\n        return preg_match('/^(\\d{4})-(\\d{1,2})-(\\d{1,2})$/', $value);\n    }\n\n    /**\n     * @param $hex\n     *\n     * @return string\n     */\n    public static function fromHex($hex): string\n    {\n        $str = '';\n        for ($i = 0; $i < strlen($hex); $i += 2) {\n            $str .= chr(hexdec(substr($hex, $i, 2)));\n        }\n\n        return $str;\n    }\n}\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/Str.php b/src/Str.php
--- a/src/Str.php	(revision dd6b46f02789ea4bb13c9ae4f8037fac2198c60d)
+++ b/src/Str.php	(date 1680779806050)
@@ -658,7 +658,7 @@
      *
      * @return bool
      */
-    public static function startsWith($haystack, $needles)
+    public static function startsWith(string $haystack, $needles)
     {
         foreach ((array)$needles as $needle) {
             if ($needle != '' && substr($haystack, 0, strlen($needle)) === (string)$needle) {
